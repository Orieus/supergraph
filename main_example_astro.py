#! /usr/bin/env python3
# -*- coding: utf-8 -*-

"""
A supergraph for the analysis of data from the Newton telescope.

Created on Oct, 15, 2024

@author: Jes√∫s Cid
"""

# Imports
import pathlib

# Local imports
from rdigraphs.sgtaskmanager import SgTaskManager

# #######################
# Configurable parameters
# #######################

# Set to True if you want to delete any previous graph and start from scratch
# Set to False to use the existing graph of windows. Only the transductive
# graph (i.e. the graph of signals) will be (re)generated.
reset_window_graph = False
reset_window_layout = False
reset_signal_graph = False
reset_signal_layout = False

# Select folder to save all data generated by this script
path2project = pathlib.Path('..') / 'projects' / f'starw_00'
# Select parent folder that contains all the input data folders (windows)
path2source = pathlib.Path('..') / 'datasets'
# Select the specific input folder to use in this project.
Gw = 'starw'

# Dictionary of cases
case = {
    "sigsum": {"s_metric": "sum_sum",
               "th": 0.02,},
    "sigmax": {"s_metric": "max_max",
               "th": 0.85},
    "sigmap": {"s_metric": "lin_sum",
               "th": 0.05}
    }

# Names of the graphs
Gs = "sigmap"              # Name of the secondary graph
BGws = f"windows_2_{Gs}"    # Name of the bipartite graph

# This is to take all attributes from the input data
params = {'select_all': True}

# Graph of windows
sim = 'ncosine'          # Similarity measure
n_epn = 17               # Number of edges per node
cd_algorithm = 'leiden'  # Community detection algorithm
nw_layout = 500          # Number of iterations for the layout (~200 is fine)
# No. of connected components (if n, only nodes from the n largest connected
# components are kept)
ncc_w = 1

# Graph of signals
th = case[Gs]['th']      # Threshold for filtering edges
order = 1               # Order of the transductive graph
ns_layout = 500        # Number of iterations for the layout
# No. of connected components (if n, only nodes from the n largest connected
# components are kept)
ncc_s = 1
# Name of the attribute in the dataset that identifies the signal
signal_attribute = 'signal'
# Similarity metric between signals  (sum_sum, max_max or lin_sum)
s_metric = case[Gs]['s_metric']


# #########################
# Launch supergraph project
# #########################

# Open task manager
paths2data = {}
tm = SgTaskManager(path2project, paths2data, path2source, keep_active=True)
paths2data = {'graphs': path2project / 'graphs',
              'bigraphs': path2project / 'bigraphs'}

# Load or create project
if not reset_window_graph and path2project.is_dir():
    tm.load()
    tm.SG.describe()     # This shows a summary of the current supergraph
else:
    tm.create()
    tm.setup()

# ###########################
# Similarity graph of windows
# ###########################

# Get list of the available graphs with saved attributes
graphs = tm.SG.get_snodes_with_features()

# Generate graph of windows (with no edges) if it does not exist
if Gw not in graphs:
    tm.import_snode_from_table(Gw, n0=0, sampling_factor=1, params=params)

# Compute similarity graph
if reset_window_graph or Gw not in graphs:
    # Compute similarity graph
    n_edges = int(n_epn * tm.SG.snodes[Gw].n_nodes)   # Target number of edges
    tm.SG.computeSimGraph(Gw, n_edges=n_edges, similarity=sim, g=1,
                          blocksize=10_000, useGPU=False, verbose=False)

tm.SG.describe(Gw)

# Compute connected components
if 'cc' not in tm.SG.get_attributes(Gw):
    tm.SG.detectCommunities(Gw, alg='cc', ncmax=None, comm_label='cc')

    # Take the largest connected components
    tm.SG.sub_snode_by_threshold(Gw, 'cc', ncc_w - 1, bound='upper',
                                 sampleT=True)

# Detect communities.
if cd_algorithm not in tm.SG.get_attributes(Gw):
    tm.SG.detectCommunities(
        Gw, alg=cd_algorithm, ncmax=None, comm_label=cd_algorithm, seed=43)

# #############
# Display graph
# #############

if reset_window_graph or reset_window_layout:
    # Attribute to define the color of the nodes
    color_att = cd_algorithm
    # Computing graph layout
    print(f'Computing layout for graph {Gw} with attribute {color_att}')
    tm.SG.graph_layout(Gw, color_att, gravity=1, alg='fa2',
                       num_iterations=nw_layout)
    tm.SG.display_graph(Gw, color_att, size_att=None, base_node_size=None,
                        edge_width=0.01)

# The graph of windows is ready. Save supergraph.
tm.SG.save_supergraph()

# #####################################
# Graph of signals (transductive graph)
# #####################################

if reset_signal_graph:
    tm.SG.snode_from_atts(Gw, signal_attribute, target=Gs, e_label=BGws,
                        save_T=False)

    # Transductive graph
    tm.SG.transduce(BGws, n=order, normalize=True, method=s_metric)

    # ##########################
    # Centrality measures
    # ##########################

    # Compute local metrics
    local_metrics = ['centrality', 'degree', 'betweenness', 'pageRank']
    for metric in local_metrics:
        print(f"-- -- Metric: {metric}")
        try:
            tm.SG.local_snode_analysis(Gs, parameter=metric)
        except Exception as e:
            print(f"Error computing {metric}: {e}")

    # ##########################
    # Strongly connected cluster
    # ##########################

    # To remove weak edges, that maybe characteristic of noisy signals
    # tm.SG.filter_edges_from_snode(Gs, th)
    # To take the largest connected components
    # tm.SG.detectCommunities(Gs, alg='cc', ncmax=None, comm_label='cc')
    # tm.SG.sub_snode_by_threshold(Gs, 'cc', ncc_s-1, bound='upper', sampleT=True)

    # To identify communities in the graph of signals
    tm.SG.detectCommunities(Gs, alg=cd_algorithm, ncmax=None,
                            comm_label=cd_algorithm, seed=43)

if reset_signal_graph or reset_signal_layout:
    # Plot transductive graph
    tm.SG.graph_layout(Gs, cd_algorithm, gravity=1, alg='fa2',
                    num_iterations=ns_layout)

# Save the whole supergraph structure.
tm.SG.save_supergraph()

if 'x' in tm.SG.get_attributes(Gs):
    # Remove weak edges. Note that this operation is not save in the
    # supergraph (to avoid destroying information)
    tm.SG.filter_edges_from_snode(Gs, th)
    print(f"Number of edges after filtering: {tm.SG.snodes[Gs].n_edges}")

    # To plot the graph of signals in a png file
    color_att = cd_algorithm
    tm.SG.display_graph(
        Gs, color_att, size_att='pageRank', base_node_size=40000,
        edge_width=0.01, show_labels=None, path=None)

# breakpoint()
