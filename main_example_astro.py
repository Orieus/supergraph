#! /usr/bin/env python3
# -*- coding: utf-8 -*-

"""
A supergraph for the analysis of data from the Newton telescope.

Created on Oct, 15, 2024

@author: Jes√∫s Cid
"""

# Imports
import pathlib
import matplotlib.pyplot as plt

# Local imports
from rdigraphs.sgtaskmanager import SgTaskManager

# #######################
# Configurable parameters
# #######################

# Set to True if you want to delete any previous graph and start from scratch
# Set to False to use the existing graph of windows. Only the transductive
# graph (i.e. the graph of signals) will be (re)generated.
reset_window_graph = False
reset_window_layout = False
reset_signal_graph = True
reset_signal_layout = True

# Select folder to save all data generated by this script
path2project = pathlib.Path('..') / 'projects' / f'probando'
# Select parent folder that contains all the input data folders (windows)
path2source = pathlib.Path('..') / 'datasets'
# Select the specific input folder to use in this project.
Gw = 'starw'

# Dictionary of cases
case = {"sigsum": {"s_metric": "sum_sum", "th": 0.02,},
        "sigmax": {"s_metric": "max_max", "th": 0.85},
        "sigmap": {"s_metric": "lin_sum", "th": 0.05}}

# Names of the graphs
Gs = "sigsum"              # Name of the secondary graph
BGws = f"{Gw}_2_{Gs}"    # Name of the bipartite graph

# This is to take all attributes from the input data
params = {'select_all': True}

# Graph of windows
sim = 'ncosine'          # Similarity measure
n_epn = 17               # Number of edges per node
cd_algorithm = 'leiden'  # Community detection algorithm
color_att_w = 'main_type'  # Attribute to define the color of the nodes
nw_layout = 10          # Number of iterations for the layout (~200 is fine)
# No. of connected components (if n, only nodes from the n largest connected
# components are kept)
ncc_w = 1

# Graph of signals
th = case[Gs]['th']      # Threshold for filtering edges
order = 1               # Order of the transductive graph
ns_layout = 500        # Number of iterations for the layout
# No. of connected components (if n, only nodes from the n largest connected
# components are kept)
ncc_s = 1
# Name of the attribute in the dataset that identifies the signal
signal_attribute = 'signal'
color_att_s = 'main_type'  # Attribute to define the color of the nodes
# Similarity metric between signals  (sum_sum, max_max or lin_sum)
s_metric = case[Gs]['s_metric']


# #########################
# Launch supergraph project
# #########################

# Open task manager
paths2data = {}
tm = SgTaskManager(path2project, paths2data, path2source, keep_active=True)
paths2data = {'graphs': path2project / 'graphs',
              'bigraphs': path2project / 'bigraphs'}

# Load or create project
if not reset_window_graph and path2project.is_dir():
    tm.load()
    tm.SG.describe()     # This shows a summary of the current supergraph
else:
    tm.create()
    tm.setup()

# ###########################
# Similarity graph of windows
# ###########################

# Get list of the available graphs with saved attributes
graphs = tm.SG.get_snodes_with_features()

# Generate graph of windows (with no edges) if it does not exist
if Gw not in graphs:
    tm.import_snode_from_table(Gw, n0=0, sampling_factor=1, params=params)

# Compute similarity graph
if reset_window_graph or Gw not in graphs:
    # Compute similarity graph
    n_edges = int(n_epn * tm.SG.snodes[Gw].n_nodes)   # Target number of edges
    tm.SG.computeSimGraph(Gw, n_edges=n_edges, similarity=sim, g=1,
                          blocksize=10_000, useGPU=False, verbose=False)

tm.SG.describe(Gw)

# Compute connected components
if 'cc' not in tm.SG.get_attributes(Gw):
    tm.SG.detectCommunities(Gw, alg='cc', ncmax=None, comm_label='cc')

    # Take the largest connected components
    tm.SG.sub_snode_by_threshold(Gw, 'cc', ncc_w - 1, bound='upper',
                                 sampleT=True)

# Detect communities.
if cd_algorithm not in tm.SG.get_attributes(Gw):
    tm.SG.detectCommunities(
        Gw, alg=cd_algorithm, ncmax=None, comm_label=cd_algorithm, seed=43)

# #############
# Display graph
# #############
if reset_window_graph or reset_window_layout:
    # Computing graph layout
    print(f'Computing layout for graph {Gw} with attribute {color_att_w}')
    tm.SG.graph_layout(Gw, color_att_w, gravity=1, alg='fa2',
                       num_iterations=nw_layout)

if 'x' in tm.SG.get_attributes(Gw):
    att_2_rgb = tm.SG.display_graph(
        Gw, color_att_w, size_att=None, base_node_size=None, edge_width=0.01)

# The graph of windows is ready. Save supergraph.
tm.SG.save_supergraph()

# #####################################
# Graph of signals (transductive graph)
# #####################################

if reset_signal_graph:
    tm.SG.snode_from_atts(Gw, signal_attribute, target=Gs, e_label=BGws,
                        save_T=False)

    # Transductive graph
    tm.SG.transduce(BGws, n=order, normalize=True, method=s_metric)

    # Add signal attribute to the nodes of the transductive graph
    tm.SG.activate_snode(Gw)
    df_types = tm.SG.snodes[Gw].df_nodes.loc[:, ['signal', 'main_type']]
    # Remove repeated rows in the dataframe
    df_types = df_types.drop_duplicates()

    tm.SG.add_snode_attributes(Gs, 'signal', df_types, fill_value='unknown')

    # ##########################
    # Centrality measures
    # ##########################

    # Compute local metrics
    local_metrics = ['centrality', 'degree', 'betweenness', 'pageRank']
    for metric in local_metrics:
        print(f"-- -- Metric: {metric}")
        try:
            tm.SG.local_snode_analysis(Gs, parameter=metric)
        except Exception as e:
            print(f"Error computing {metric}: {e}")

    # ##########################
    # Strongly connected cluster
    # ##########################

    # To remove weak edges, that maybe characteristic of noisy signals
    # tm.SG.filter_edges_from_snode(Gs, th)
    # To take the largest connected components
    # tm.SG.detectCommunities(Gs, alg='cc', ncmax=None, comm_label='cc')
    # tm.SG.sub_snode_by_threshold(Gs, 'cc', ncc_s-1, bound='upper', sampleT=True)

    # To identify communities in the graph of signals
    tm.SG.detectCommunities(Gs, alg=cd_algorithm, ncmax=None,
                            comm_label=cd_algorithm, seed=43)

if reset_signal_graph or reset_signal_layout:
    # Plot transductive graph
    tm.SG.graph_layout(Gs, color_att_s, gravity=1, alg='fa2',
                    num_iterations=ns_layout)

# Save the whole supergraph structure.
tm.SG.save_supergraph()

if 'x' in tm.SG.get_attributes(Gs):
    # Remove weak edges. Note that this operation is not save in the
    # supergraph (to avoid destroying information)
    tm.SG.filter_edges_from_snode(Gs, th)
    print(f"Number of edges after filtering: {tm.SG.snodes[Gs].n_edges}")

    # To plot the graph of signals in a png file
    color_att = cd_algorithm
    att_2_rgb = tm.SG.display_graph(
        Gs, color_att_s, size_att='pageRank', base_node_size=40000,
        edge_width=0.01, show_labels=None, path=None)


# ########################
# Analyze types of signals
# ########################

# Get community labels from the snodes of the community graph
tm.SG.activate_snode(Gs)
unique_comm_names = list(att_2_rgb.keys())
comm_names = tm.SG.snodes[Gs].df_nodes.main_type.tolist()
# Compute a dictionary with the frequency of each community
comm_dict = dict(zip(tm.SG.snodes[Gs].df_nodes.Id.tolist(), comm_names))

freq = {name: 0 for name in unique_comm_names}
for label in comm_names:
    freq[label] += 1
print(freq)

# Sort dictionary by decreasing values
freqs = list(freq.values())
colors = att_2_rgb.values()
sorted_tuples = sorted(zip(freqs, unique_comm_names, colors), reverse=True)
sorted_freqs, sorted_comm_names, sorted_colors = zip(*sorted_tuples)

# Plot a pie chart with the frequency of each community
plt.figure(figsize=(10, 6))
plt.pie(sorted_freqs, labels=sorted_comm_names, autopct='%1.1f%%',
        colors=sorted_colors)
plt.title('EU projects by community')
plt.show(block=False)

# Save figure in the following path
tm.SG.activate_snode(Gs)
path = tm.SG.snodes[Gs].path2graph / 'pie_chart.png'
plt.savefig(path)


breakpoint()
