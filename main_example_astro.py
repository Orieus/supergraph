#! /usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Main program for the RDIgraph analyzer

Created on June 18 2018

@author: Jes√∫s Cid Sueiro

# For profiling: kernprof -lv mainRDIgraph.py ...

"""

# Imports
import pathlib

# Local imports
from rdigraphs.sgtaskmanager import SgTaskManager

# #######################
# Configurable parameters
# #######################

# Set to True if you want to delete any previous graph and start from scratch
# Set to False to use the existing graph of windows. Only the transductive
# graph (i.e. the graph of signals) will be (re)generated.
reset_graph = False
# Set to True to plot the graph of windows in a png file
plot_graph = True

# Select folder to save all data generated by this script
path2project = pathlib.Path('..') / 'projects' / f'stars_s03'
# Select parent folder that contains all the input data folders (windows)
path2source = pathlib.Path('..') / 'datasets'
# Select the specific input folder to use in this project.
Gw = 'starw'

# This is to take all attributes from the input data
params = {'select_all': True}

# Graph of windows
sim = 'ncosine'          # Similarity measure
n_epn = 17               # Number of edges per node
cd_algorithm = 'leiden'  # Community detection algorithm
nw_layout = 500          # Number of iterations for the layout
# No. of connected components (if n, only nodes from the n largest connected
# components are kept)
ncc_w = 1

# Graph of signals
th = 0.04   # 0.16      # Threshold for filtering edges
order = 1               # Order of the transductive graph
ns_layout = 4000        # Number of iterations for the layout
# No. of connected components (if n, only nodes from the n largest connected
# components are kept)
ncc_s = 1

# Select the attribute to build the secondary graph
signal_attribute = 'signal'

# #########################
# Launch supergraph project
# #########################

# Open task manager
paths2data = {}
tm = SgTaskManager(path2project, paths2data, path2source, keep_active=True)
paths2data = {'graphs': path2project / 'graphs',
              'bigraphs': path2project / 'bigraphs'}

# Load or create project
if not reset_graph and path2project.is_dir():
    tm.load()
    tm.SG.describe()     # This shows a summary of the current supergraph
else:
    tm.create()
    tm.setup()

# ###########################
# Similarity graph of windows
# ###########################

# Get list of the available graphs with saved attributes
graphs = tm.get_graphs_with_features()

# Generate graph of windows (with no edges) if it does not exist
if Gw not in graphs:
    tm.import_snode_from_table(Gw, n0=0, sampling_factor=1, params=params)

# Path to the graph
path2Gw = paths2data['graphs'] / Gw

# Compute similarity graph
if reset_graph or Gw not in graphs:
    tm.SG.activate_snode(Gw)    # To load graph in memory

    # Compute similarity graph
    n_edges = int(n_epn * tm.SG.snodes[Gw].n_nodes)   # Target number of edges
    tm.SG.computeSimGraph(Gw, n_edges=n_edges, similarity=sim, g=1,
                          blocksize=10_000, useGPU=False, verbose=True)

    tm.SG.snodes[Gw].describe()

# Connected components
if 'cc' not in tm.SG.get_attributes(Gw):
    tm.SG.detectCommunities(Gw, alg='cc', ncmax=None, comm_label='cc')

    # Take the largest connected components
    tm.SG.sub_snode_by_threshold(Gw, 'cc', ncc_w - 1, bound='upper',
                                 sampleT=True)

# Detect communities.
if cd_algorithm not in tm.SG.get_attributes(Gw):
    tm.SG.detectCommunities(
        Gw, alg=cd_algorithm, ncmax=None, comm_label=cd_algorithm, seed=43)

# ##########
# Plot graph
# ##########

# Attribute to define the color of the nodes
color_att = cd_algorithm

# Computing graph layout
print(f'Computing layout for graph {Gw} with attribute {color_att}')
if reset_graph:
    tm.SG.graph_layout(Gw, color_att, gravity=1, alg='fa2',
                       num_iterations=nw_layout)
if plot_graph:
    tm.SG.display_graph(Gw, color_att, size_att=None, base_node_size=None,
                        edge_width=0.2)

# The graph of windows is ready. Save supergraph.
tm.SG.save_supergraph()

# ##################
# Transductive graph
# ##################

# Bipartite graph windows-signals
BGws = "windows_2_signals"  # Name of the bipartite graph
Gs = "signals"              # Name of the secondary graph
tm.SG.snode_from_atts(Gw, signal_attribute, target=Gs, e_label=BGws,
                      save_T=True)

# Transductive graph
tm.SG.transduce(BGws, n=order, normalize=True)

# ############################
# Centrality measures
# ############################

local_metrics = ['centrality', 'degree', 'betweenness', 'pageRank']

# Compute local metrics
for metric in local_metrics:
    print(f"-- -- Metric: {metric}")
    tm.SG.local_snode_analysis(Gs, parameter=metric)

# ##########################
# Strongly connected cluster
# ##########################

# To remove weak edges, that maybe characteristic of noisy signals
# tm.SG.filter_edges_from_snode(Gs, th)

# To take the largest connected components
# tm.SG.detectCommunities(Gs, alg='cc', ncmax=None, comm_label='cc')
# tm.SG.sub_snode_by_threshold(Gs, 'cc', ncc_s-1, bound='upper', sampleT=True)

# To identify communities in the graph of signals
tm.SG.detectCommunities(Gs, alg=cd_algorithm, ncmax=None,
                        comm_label=cd_algorithm, seed=43)

# Plot transductive graph
tm.SG.graph_layout(Gs, cd_algorithm, gravity=1, alg='fa2',
                   num_iterations=ns_layout)

# To remove weak edges
# tm.SG.filter_edges_from_snode(Gs, 2*th)

# To plot the graph of signals in a png file
tm.SG.display_graph(Gs, color_att, size_att='pageRank', base_node_size=40000,
                    edge_width=0.2, show_labels=None, path=None)

# Save the whole supergraph structure.
tm.SG.save_supergraph()

breakpoint()








